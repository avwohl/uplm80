/*
 * COMPREHENSIVE TEST SUITE FOR UPLM80 PL/M-80 COMPILER
 *
 * TESTS ALL LANGUAGE FEATURES AND PRINTS RESULTS
 * FORMAT: testname value
 *
 * BUILD:
 *   python -m uplm80.compiler tests/test_all.plm -o tests/test_all.mac
 *   um80 tests/test_all.mac
 *   ul80 -o tests/test_all.com tests/test_all.rel tests/test_stubs.rel
 *   cpmemu tests/test_all.com > tests/test_output.txt
 *   diff tests/test_output.txt tests/test_expected.txt
 */

0100H:  /* CP/M ORIGIN */

TESTSUITE:
DO;

DECLARE CR LITERALLY '13';
DECLARE LF LITERALLY '10';
DECLARE TRUE LITERALLY '0FFH';
DECLARE FALSE LITERALLY '0';

/* CP/M BDOS INTERFACE */
MON1: PROCEDURE(FUNC, PARM) EXTERNAL;
    DECLARE FUNC BYTE, PARM ADDRESS;
END MON1;
MON2: PROCEDURE(FUNC, PARM) BYTE EXTERNAL;
    DECLARE FUNC BYTE, PARM ADDRESS;
END MON2;

/* GLOBAL TEST VARIABLES */
DECLARE PASS$COUNT ADDRESS;
DECLARE FAIL$COUNT ADDRESS;

/* ==================================================================
 * OUTPUT ROUTINES
 * ================================================================== */

/* PRINT SINGLE CHARACTER */
PRINT$CHAR: PROCEDURE(C);
    DECLARE C BYTE;
    CALL MON1(2, C);
END PRINT$CHAR;

/* PRINT STRING TERMINATED BY '$' */
PRINT$STR: PROCEDURE(S);
    DECLARE S ADDRESS;
    CALL MON1(9, S);
END PRINT$STR;

/* PRINT NEWLINE */
CRLF: PROCEDURE;
    CALL PRINT$CHAR(CR);
    CALL PRINT$CHAR(LF);
END CRLF;

/* PRINT UNSIGNED 16-BIT NUMBER */
PRINT$NUM: PROCEDURE(N);
    DECLARE N ADDRESS;
    DECLARE BUFFER(6) BYTE;
    DECLARE I BYTE;

    IF N = 0 THEN DO;
        CALL PRINT$CHAR('0');
        RETURN;
    END;

    I = 0;
    DO WHILE N > 0;
        BUFFER(I) = (N MOD 10) + '0';
        N = N / 10;
        I = I + 1;
    END;

    /* PRINT DIGITS IN REVERSE ORDER */
    DO WHILE I > 0;
        I = I - 1;
        CALL PRINT$CHAR(BUFFER(I));
    END;
END PRINT$NUM;

/* PRINT SIGNED NUMBER */
PRINT$SIGNED: PROCEDURE(N);
    DECLARE N ADDRESS;
    /* CHECK IF NEGATIVE (HIGH BIT SET) */
    IF N > 32767 THEN DO;
        CALL PRINT$CHAR('-');
        N = (NOT N) + 1;  /* TWO'S COMPLEMENT */
    END;
    CALL PRINT$NUM(N);
END PRINT$SIGNED;

/* PRINT TEST RESULT */
PRINT$TEST: PROCEDURE(NAME, VALUE);
    DECLARE NAME ADDRESS;
    DECLARE VALUE ADDRESS;
    CALL PRINT$STR(NAME);
    CALL PRINT$CHAR(' ');
    CALL PRINT$NUM(VALUE);
    CALL CRLF;
END PRINT$TEST;

/* PRINT SIGNED TEST RESULT */
PRINT$STEST: PROCEDURE(NAME, VALUE);
    DECLARE NAME ADDRESS;
    DECLARE VALUE ADDRESS;
    CALL PRINT$STR(NAME);
    CALL PRINT$CHAR(' ');
    CALL PRINT$SIGNED(VALUE);
    CALL CRLF;
END PRINT$STEST;

/* ==================================================================
 * TEST SECTION 1: BASIC ARITHMETIC
 * ================================================================== */

TEST$ARITHMETIC: PROCEDURE;
    DECLARE A ADDRESS, B ADDRESS;
    DECLARE X BYTE, Y BYTE;

    /* 16-BIT ADDITION */
    A = 100;
    B = 200;
    CALL PRINT$TEST(.'add16 $', A + B);  /* 300 */

    /* 16-BIT SUBTRACTION */
    A = 500;
    B = 123;
    CALL PRINT$TEST(.'sub16 $', A - B);  /* 377 */

    /* 16-BIT MULTIPLICATION */
    A = 25;
    B = 12;
    CALL PRINT$TEST(.'mul16 $', A * B);  /* 300 */

    /* 16-BIT DIVISION */
    A = 1000;
    B = 7;
    CALL PRINT$TEST(.'div16 $', A / B);  /* 142 */

    /* 16-BIT MODULO */
    A = 1000;
    B = 7;
    CALL PRINT$TEST(.'mod16 $', A MOD B);  /* 6 */

    /* 8-BIT OPERATIONS */
    X = 15;
    Y = 10;
    CALL PRINT$TEST(.'add8 $', X + Y);  /* 25 */
    CALL PRINT$TEST(.'sub8 $', X - Y);  /* 5 */
    CALL PRINT$TEST(.'mul8 $', X * Y);  /* 150 */

    /* BYTE DIVISION */
    X = 100;
    Y = 7;
    CALL PRINT$TEST(.'div8 $', X / Y);  /* 14 */
    CALL PRINT$TEST(.'mod8 $', X MOD Y);  /* 2 */

    /* UNARY MINUS */
    A = 100;
    CALL PRINT$STEST(.'neg16 $', -A);  /* -100 */

    /* COMPLEX EXPRESSION */
    A = 10;
    B = 3;
    CALL PRINT$TEST(.'expr1 $', (A + B) * 2 - 4);  /* 22 */

    /* OPERATOR PRECEDENCE: * BEFORE + */
    CALL PRINT$TEST(.'prec1 $', 2 + 3 * 4);  /* 14 */

    /* OPERATOR PRECEDENCE WITH PARENS */
    CALL PRINT$TEST(.'prec2 $', (2 + 3) * 4);  /* 20 */

END TEST$ARITHMETIC;

/* ==================================================================
 * TEST SECTION 2: BITWISE OPERATIONS
 * ================================================================== */

TEST$BITWISE: PROCEDURE;
    DECLARE A ADDRESS, B ADDRESS;
    DECLARE X BYTE;

    /* AND */
    A = 0FFH;
    B = 0F0H;
    CALL PRINT$TEST(.'and1 $', A AND B);  /* 240 */

    /* OR */
    A = 0F0H;
    B = 0FH;
    CALL PRINT$TEST(.'or1 $', A OR B);  /* 255 */

    /* XOR */
    A = 0FFH;
    B = 0AAH;
    CALL PRINT$TEST(.'xor1 $', A XOR B);  /* 85 */

    /* NOT */
    X = 0;
    CALL PRINT$TEST(.'not1 $', NOT X);  /* 255 */
    X = 0AAH;
    CALL PRINT$TEST(.'not2 $', NOT X);  /* 85 */

    /* COMBINED */
    A = 0F0H;
    B = 0FH;
    CALL PRINT$TEST(.'bit1 $', (A OR B) AND 0FFH);  /* 255 */

END TEST$BITWISE;

/* ==================================================================
 * TEST SECTION 3: SHIFT OPERATIONS
 * ================================================================== */

TEST$SHIFTS: PROCEDURE;
    DECLARE A ADDRESS;

    /* SHL - SHIFT LEFT */
    A = 1;
    CALL PRINT$TEST(.'shl1 $', SHL(A, 4));  /* 16 */

    A = 5;
    CALL PRINT$TEST(.'shl2 $', SHL(A, 3));  /* 40 */

    /* SHR - SHIFT RIGHT */
    A = 256;
    CALL PRINT$TEST(.'shr1 $', SHR(A, 4));  /* 16 */

    A = 80;
    CALL PRINT$TEST(.'shr2 $', SHR(A, 2));  /* 20 */

    /* SHIFT BY ZERO */
    A = 42;
    CALL PRINT$TEST(.'shl0 $', SHL(A, 0));  /* 42 */
    CALL PRINT$TEST(.'shr0 $', SHR(A, 0));  /* 42 */

END TEST$SHIFTS;

/* ==================================================================
 * TEST SECTION 4: COMPARISON OPERATORS
 * ================================================================== */

TEST$COMPARE: PROCEDURE;
    DECLARE A ADDRESS, B ADDRESS;

    A = 10;
    B = 20;

    /* EQUALITY */
    IF A = B THEN
        CALL PRINT$TEST(.'eq1 $', 0);
    ELSE
        CALL PRINT$TEST(.'eq1 $', 1);  /* 1 */

    IF A = 10 THEN
        CALL PRINT$TEST(.'eq2 $', 1);  /* 1 */
    ELSE
        CALL PRINT$TEST(.'eq2 $', 0);

    /* INEQUALITY */
    IF A <> B THEN
        CALL PRINT$TEST(.'neq1 $', 1);  /* 1 */
    ELSE
        CALL PRINT$TEST(.'neq1 $', 0);

    /* LESS THAN */
    IF A < B THEN
        CALL PRINT$TEST(.'lt1 $', 1);  /* 1 */
    ELSE
        CALL PRINT$TEST(.'lt1 $', 0);

    IF B < A THEN
        CALL PRINT$TEST(.'lt2 $', 1);
    ELSE
        CALL PRINT$TEST(.'lt2 $', 0);  /* 0 */

    /* GREATER THAN */
    IF B > A THEN
        CALL PRINT$TEST(.'gt1 $', 1);  /* 1 */
    ELSE
        CALL PRINT$TEST(.'gt1 $', 0);

    /* LESS THAN OR EQUAL */
    A = 10;
    B = 10;
    IF A <= B THEN
        CALL PRINT$TEST(.'lte1 $', 1);  /* 1 */
    ELSE
        CALL PRINT$TEST(.'lte1 $', 0);

    /* GREATER THAN OR EQUAL */
    IF A >= B THEN
        CALL PRINT$TEST(.'gte1 $', 1);  /* 1 */
    ELSE
        CALL PRINT$TEST(.'gte1 $', 0);

    /* COMPARISON AS VALUE */
    A = 5;
    B = 10;
    CALL PRINT$TEST(.'cmpv1 $', A < B);  /* 255 (TRUE = 0FFH) */
    CALL PRINT$TEST(.'cmpv2 $', A > B);  /* 0 (FALSE) */

END TEST$COMPARE;

/* ==================================================================
 * TEST SECTION 5: CONTROL FLOW - DO WHILE
 * ================================================================== */

TEST$WHILE: PROCEDURE;
    DECLARE I ADDRESS;
    DECLARE SUM ADDRESS;

    /* SIMPLE DO WHILE */
    SUM = 0;
    I = 1;
    DO WHILE I <= 5;
        SUM = SUM + I;
        I = I + 1;
    END;
    CALL PRINT$TEST(.'while1 $', SUM);  /* 15 = 1+2+3+4+5 */

    /* WHILE WITH ZERO ITERATIONS */
    SUM = 99;
    I = 10;
    DO WHILE I < 5;
        SUM = 0;
        I = I + 1;
    END;
    CALL PRINT$TEST(.'while2 $', SUM);  /* 99 (loop not entered) */

END TEST$WHILE;

/* ==================================================================
 * TEST SECTION 6: CONTROL FLOW - ITERATIVE DO
 * ================================================================== */

TEST$ITERATIVE: PROCEDURE;
    DECLARE I ADDRESS;
    DECLARE SUM ADDRESS;

    /* SIMPLE ITERATIVE DO */
    SUM = 0;
    DO I = 1 TO 5;
        SUM = SUM + I;
    END;
    CALL PRINT$TEST(.'iter1 $', SUM);  /* 15 */

    /* WITH STEP */
    SUM = 0;
    DO I = 0 TO 10 BY 2;
        SUM = SUM + I;
    END;
    CALL PRINT$TEST(.'iter2 $', SUM);  /* 30 = 0+2+4+6+8+10 */

    /* NESTED LOOPS */
    DECLARE J ADDRESS;
    SUM = 0;
    DO I = 1 TO 3;
        DO J = 1 TO 3;
            SUM = SUM + 1;
        END;
    END;
    CALL PRINT$TEST(.'iter3 $', SUM);  /* 9 */

END TEST$ITERATIVE;

/* ==================================================================
 * TEST SECTION 7: CONTROL FLOW - DO CASE
 * ================================================================== */

TEST$CASE: PROCEDURE;
    DECLARE SEL BYTE;
    DECLARE RESULT ADDRESS;

    /* CASE 0 - SMALL DO CASE (3 CASES, USES SEQUENTIAL COMPARISONS) */
    SEL = 0;
    RESULT = 99;
    DO CASE SEL;
        RESULT = 100;  /* CASE 0 */
        RESULT = 101;  /* CASE 1 */
        RESULT = 102;  /* CASE 2 */
    END;
    CALL PRINT$TEST(.'case0 $', RESULT);  /* 100 */

    /* CASE 1 */
    SEL = 1;
    RESULT = 99;
    DO CASE SEL;
        RESULT = 100;  /* CASE 0 */
        RESULT = 101;  /* CASE 1 */
        RESULT = 102;  /* CASE 2 */
    END;
    CALL PRINT$TEST(.'case1 $', RESULT);  /* 101 */

    /* CASE 2 */
    SEL = 2;
    RESULT = 99;
    DO CASE SEL;
        RESULT = 100;  /* CASE 0 */
        RESULT = 101;  /* CASE 1 */
        RESULT = 102;  /* CASE 2 */
    END;
    CALL PRINT$TEST(.'case2 $', RESULT);  /* 102 */

    /* OUT OF RANGE (SHOULD SKIP ALL) */
    SEL = 5;
    RESULT = 99;
    DO CASE SEL;
        RESULT = 100;  /* CASE 0 */
        RESULT = 101;  /* CASE 1 */
        RESULT = 102;  /* CASE 2 */
    END;
    CALL PRINT$TEST(.'case3 $', RESULT);  /* 99 (no case matched) */

    /* EXACTLY 8 CASES - BOUNDARY (STILL USES SEQUENTIAL COMPARISONS) */
    SEL = 5;
    RESULT = 0;
    DO CASE SEL;
        RESULT = 10;  /* CASE 0 */
        RESULT = 11;  /* CASE 1 */
        RESULT = 12;  /* CASE 2 */
        RESULT = 13;  /* CASE 3 */
        RESULT = 14;  /* CASE 4 */
        RESULT = 15;  /* CASE 5 */
        RESULT = 16;  /* CASE 6 */
        RESULT = 17;  /* CASE 7 */
    END;
    CALL PRINT$TEST(.'case8a $', RESULT);  /* 15 (case 5) */

    /* LARGE DO CASE - 10 CASES (USES JUMP TABLE) */
    SEL = 3;
    RESULT = 0;
    DO CASE SEL;
        RESULT = 100;  /* CASE 0 */
        RESULT = 101;  /* CASE 1 */
        RESULT = 102;  /* CASE 2 */
        RESULT = 103;  /* CASE 3 */
        RESULT = 104;  /* CASE 4 */
        RESULT = 105;  /* CASE 5 */
        RESULT = 106;  /* CASE 6 */
        RESULT = 107;  /* CASE 7 */
        RESULT = 108;  /* CASE 8 */
        RESULT = 109;  /* CASE 9 */
    END;
    CALL PRINT$TEST(.'case10a $', RESULT);  /* 103 (case 3) */

    /* LARGE DO CASE - TEST CASE 9 (LAST CASE) */
    SEL = 9;
    RESULT = 0;
    DO CASE SEL;
        RESULT = 100;  /* CASE 0 */
        RESULT = 101;  /* CASE 1 */
        RESULT = 102;  /* CASE 2 */
        RESULT = 103;  /* CASE 3 */
        RESULT = 104;  /* CASE 4 */
        RESULT = 105;  /* CASE 5 */
        RESULT = 106;  /* CASE 6 */
        RESULT = 107;  /* CASE 7 */
        RESULT = 108;  /* CASE 8 */
        RESULT = 109;  /* CASE 9 */
    END;
    CALL PRINT$TEST(.'case10b $', RESULT);  /* 109 (case 9) */

    /* LARGE DO CASE - TEST CASE 0 (FIRST CASE) */
    SEL = 0;
    RESULT = 0;
    DO CASE SEL;
        RESULT = 100;  /* CASE 0 */
        RESULT = 101;  /* CASE 1 */
        RESULT = 102;  /* CASE 2 */
        RESULT = 103;  /* CASE 3 */
        RESULT = 104;  /* CASE 4 */
        RESULT = 105;  /* CASE 5 */
        RESULT = 106;  /* CASE 6 */
        RESULT = 107;  /* CASE 7 */
        RESULT = 108;  /* CASE 8 */
        RESULT = 109;  /* CASE 9 */
    END;
    CALL PRINT$TEST(.'case10c $', RESULT);  /* 100 (case 0) */

END TEST$CASE;

/* ==================================================================
 * TEST SECTION 8: GOTO AND LABELS - DISABLED DUE TO BUG
 * ================================================================== */
/*
TEST$GOTO: PROCEDURE;
    DECLARE X ADDRESS;

    X = 0;

    GO TO GSKIP1;
    X = 99;
GSKIP1:
    CALL PRINT$TEST(.'goto1 $', X);

    X = 1;
    GOTO GSKIP2;
    X = 99;
GSKIP2:
    CALL PRINT$TEST(.'goto2 $', X);

    X = 5;
    IF X = 5 THEN GO TO GDONE;
    X = 10;
GDONE:
    CALL PRINT$TEST(.'goto3 $', X);

END TEST$GOTO;
*/

/* ==================================================================
 * TEST SECTION 9: ARRAYS
 * ================================================================== */

TEST$ARRAYS: PROCEDURE;
    DECLARE ARR(10) BYTE;
    DECLARE AARR(5) ADDRESS;
    DECLARE I BYTE;
    DECLARE SUM ADDRESS;

    /* INITIALIZE BYTE ARRAY */
    DO I = 0 TO 9;
        ARR(I) = I * 2;
    END;
    CALL PRINT$TEST(.'arr1 $', ARR(0));  /* 0 */
    CALL PRINT$TEST(.'arr2 $', ARR(5));  /* 10 */
    CALL PRINT$TEST(.'arr3 $', ARR(9));  /* 18 */

    /* ADDRESS ARRAY */
    AARR(0) = 1000;
    AARR(1) = 2000;
    AARR(2) = 3000;
    CALL PRINT$TEST(.'aarr1 $', AARR(0));  /* 1000 */
    CALL PRINT$TEST(.'aarr2 $', AARR(1));  /* 2000 */
    CALL PRINT$TEST(.'aarr3 $', AARR(2));  /* 3000 */

    /* SUM ARRAY ELEMENTS */
    SUM = 0;
    DO I = 0 TO 4;
        SUM = SUM + ARR(I);
    END;
    CALL PRINT$TEST(.'arrsum $', SUM);  /* 0+2+4+6+8 = 20 */

    /* LENGTH BUILTIN */
    CALL PRINT$TEST(.'len1 $', LENGTH(ARR));  /* 10 */
    CALL PRINT$TEST(.'len2 $', LENGTH(AARR));  /* 5 */

    /* LAST BUILTIN */
    CALL PRINT$TEST(.'last1 $', LAST(ARR));  /* 9 */
    CALL PRINT$TEST(.'last2 $', LAST(AARR));  /* 4 */

    /* SIZE BUILTIN */
    CALL PRINT$TEST(.'size1 $', SIZE(ARR));  /* 10 (10 bytes) */
    CALL PRINT$TEST(.'size2 $', SIZE(AARR));  /* 10 (5 * 2 bytes) */

END TEST$ARRAYS;

/* ==================================================================
 * TEST SECTION 10: HIGH AND LOW BUILTINS
 * ================================================================== */

TEST$HIGHLOW: PROCEDURE;
    DECLARE A ADDRESS;

    A = 1234H;
    CALL PRINT$TEST(.'low1 $', LOW(A));  /* 34H = 52 */
    CALL PRINT$TEST(.'high1 $', HIGH(A));  /* 12H = 18 */

    A = 0ABCDH;
    CALL PRINT$TEST(.'low2 $', LOW(A));  /* CDH = 205 */
    CALL PRINT$TEST(.'high2 $', HIGH(A));  /* ABH = 171 */

    /* DOUBLE BUILTIN */
    CALL PRINT$TEST(.'dbl1 $', DOUBLE(1));  /* 256 */
    CALL PRINT$TEST(.'dbl2 $', DOUBLE(2));  /* 512 */

END TEST$HIGHLOW;

/* ==================================================================
 * TEST SECTION 11: PROCEDURES AND RETURN VALUES
 * ================================================================== */

/* NON-REENTRANT PROCEDURE - NO PARAMS, NO RETURN */
PROC$VOID: PROCEDURE;
    DECLARE DUMMY ADDRESS;
    DUMMY = 42;
END PROC$VOID;

/* NON-REENTRANT PROCEDURE - RETURNS BYTE */
PROC$BYTE: PROCEDURE BYTE;
    RETURN 42;
END PROC$BYTE;

/* NON-REENTRANT PROCEDURE - RETURNS ADDRESS */
PROC$ADDR: PROCEDURE ADDRESS;
    RETURN 1234;
END PROC$ADDR;

/* PROCEDURE WITH BYTE PARAMETER */
PROC$PARM1: PROCEDURE(X) BYTE;
    DECLARE X BYTE;
    RETURN X + 10;
END PROC$PARM1;

/* PROCEDURE WITH ADDRESS PARAMETER */
PROC$PARM2: PROCEDURE(A) ADDRESS;
    DECLARE A ADDRESS;
    RETURN A * 2;
END PROC$PARM2;

/* PROCEDURE WITH MULTIPLE PARAMETERS */
PROC$MULTI: PROCEDURE(A, B, C) ADDRESS;
    DECLARE A BYTE, B BYTE, C ADDRESS;
    RETURN A + B + C;
END PROC$MULTI;

/* RECURSIVE FACTORIAL (REENTRANT) */
FACTORIAL: PROCEDURE(N) ADDRESS REENTRANT;
    DECLARE N ADDRESS;
    IF N <= 1 THEN RETURN 1;
    RETURN N * FACTORIAL(N - 1);
END FACTORIAL;

TEST$PROCEDURES: PROCEDURE;
    DECLARE X BYTE;
    DECLARE A ADDRESS;

    CALL PROC$VOID;
    CALL PRINT$TEST(.'proc1 $', 1);  /* 1 (void proc executed) */

    X = PROC$BYTE;
    CALL PRINT$TEST(.'proc2 $', X);  /* 42 */

    A = PROC$ADDR;
    CALL PRINT$TEST(.'proc3 $', A);  /* 1234 */

    X = PROC$PARM1(5);
    CALL PRINT$TEST(.'proc4 $', X);  /* 15 */

    A = PROC$PARM2(100);
    CALL PRINT$TEST(.'proc5 $', A);  /* 200 */

    A = PROC$MULTI(10, 20, 1000);
    CALL PRINT$TEST(.'proc6 $', A);  /* 1030 */

    /* RECURSIVE FACTORIAL */
    A = FACTORIAL(5);
    CALL PRINT$TEST(.'fact5 $', A);  /* 120 */

    A = FACTORIAL(6);
    CALL PRINT$TEST(.'fact6 $', A);  /* 720 */

END TEST$PROCEDURES;

/* ==================================================================
 * TEST SECTION 12: STRUCTURES
 * ================================================================== */

TEST$STRUCTURES: PROCEDURE;
    DECLARE POINT STRUCTURE(X BYTE, Y BYTE);
    DECLARE RECT STRUCTURE(LEFT ADDRESS, TOP ADDRESS, RIGHT ADDRESS, BOTTOM ADDRESS);

    POINT.X = 10;
    POINT.Y = 20;
    CALL PRINT$TEST(.'stru1 $', POINT.X);  /* 10 */
    CALL PRINT$TEST(.'stru2 $', POINT.Y);  /* 20 */
    CALL PRINT$TEST(.'stru3 $', POINT.X + POINT.Y);  /* 30 */

    RECT.LEFT = 100;
    RECT.TOP = 200;
    RECT.RIGHT = 300;
    RECT.BOTTOM = 400;
    CALL PRINT$TEST(.'stru4 $', RECT.LEFT);  /* 100 */
    CALL PRINT$TEST(.'stru5 $', RECT.RIGHT - RECT.LEFT);  /* 200 */

END TEST$STRUCTURES;

/* ==================================================================
 * TEST SECTION 13: BASED VARIABLES
 * ================================================================== */

TEST$BASED: PROCEDURE;
    DECLARE BUFFER(10) BYTE;
    DECLARE PTR ADDRESS;
    DECLARE BVAR BASED PTR BYTE;
    DECLARE I BYTE;

    /* INITIALIZE BUFFER */
    DO I = 0 TO 9;
        BUFFER(I) = I + 100;
    END;

    /* ACCESS THROUGH BASED VARIABLE */
    PTR = .BUFFER(0);
    CALL PRINT$TEST(.'base1 $', BVAR);  /* 100 */

    PTR = .BUFFER(5);
    CALL PRINT$TEST(.'base2 $', BVAR);  /* 105 */

    /* MODIFY THROUGH BASED VARIABLE */
    PTR = .BUFFER(3);
    BVAR = 255;
    CALL PRINT$TEST(.'base3 $', BUFFER(3));  /* 255 */

END TEST$BASED;

/* ==================================================================
 * TEST SECTION 14: DATA INITIALIZATION
 * ================================================================== */

DECLARE INIT$ARR(5) BYTE INITIAL(10, 20, 30, 40, 50);
DECLARE DATA$STR DATA('HELLO', 0);

TEST$DATA: PROCEDURE;
    DECLARE I BYTE;
    DECLARE SUM ADDRESS;

    /* TEST INITIAL VALUES */
    CALL PRINT$TEST(.'init1 $', INIT$ARR(0));  /* 10 */
    CALL PRINT$TEST(.'init2 $', INIT$ARR(2));  /* 30 */
    CALL PRINT$TEST(.'init3 $', INIT$ARR(4));  /* 50 */

    /* SUM INITIALIZED ARRAY */
    SUM = 0;
    DO I = 0 TO 4;
        SUM = SUM + INIT$ARR(I);
    END;
    CALL PRINT$TEST(.'init4 $', SUM);  /* 150 */

    /* TEST DATA STRING - FIRST CHAR IS 'H' = 72 */
    DECLARE PTR ADDRESS;
    DECLARE C BASED PTR BYTE;
    PTR = .DATA$STR;
    CALL PRINT$TEST(.'data1 $', C);  /* 72 = 'H' */

END TEST$DATA;

/* ==================================================================
 * TEST SECTION 15: EMBEDDED ASSIGNMENT
 * ================================================================== */

TEST$EMBED: PROCEDURE;
    DECLARE X ADDRESS;
    DECLARE Y ADDRESS;

    /* EMBEDDED ASSIGNMENT IN EXPRESSION */
    Y = (X := 10) + 5;
    CALL PRINT$TEST(.'emb1 $', X);  /* 10 */
    CALL PRINT$TEST(.'emb2 $', Y);  /* 15 */

    /* CHAINED EMBEDDED ASSIGNMENTS */
    DECLARE Z ADDRESS;
    Z = (Y := (X := 20));
    CALL PRINT$TEST(.'emb3 $', X);  /* 20 */
    CALL PRINT$TEST(.'emb4 $', Y);  /* 20 */
    CALL PRINT$TEST(.'emb5 $', Z);  /* 20 */

END TEST$EMBED;

/* ==================================================================
 * TEST SECTION 16: MULTIPLE ASSIGNMENT
 * ================================================================== */

TEST$MULTI$ASSIGN: PROCEDURE;
    DECLARE A ADDRESS, B ADDRESS, C ADDRESS;

    A, B, C = 42;
    CALL PRINT$TEST(.'multi1 $', A);  /* 42 */
    CALL PRINT$TEST(.'multi2 $', B);  /* 42 */
    CALL PRINT$TEST(.'multi3 $', C);  /* 42 */

    A, B = 100 + 50;
    CALL PRINT$TEST(.'multi4 $', A);  /* 150 */
    CALL PRINT$TEST(.'multi5 $', B);  /* 150 */

END TEST$MULTI$ASSIGN;

/* ==================================================================
 * TEST SECTION 17: LOCATION OPERATOR (DOT)
 * ================================================================== */

TEST$LOCATION: PROCEDURE;
    DECLARE X BYTE;
    DECLARE ARR(10) BYTE;
    DECLARE PTR ADDRESS;

    X = 99;
    PTR = .X;
    /* PTR NOW HOLDS ADDRESS OF X */
    /* WE CAN'T EASILY VERIFY THE ADDRESS, BUT WE CAN USE IT */

    DECLARE BVAR BASED PTR BYTE;
    CALL PRINT$TEST(.'loc1 $', BVAR);  /* 99 */

    /* MODIFY THROUGH POINTER */
    BVAR = 55;
    CALL PRINT$TEST(.'loc2 $', X);  /* 55 */

    /* ARRAY ELEMENT ADDRESS */
    ARR(3) = 77;
    PTR = .ARR(3);
    CALL PRINT$TEST(.'loc3 $', BVAR);  /* 77 */

END TEST$LOCATION;

/* ==================================================================
 * TEST SECTION 18: CONSTANT LIST LOCATION
 * ================================================================== */

TEST$CONSTLIST: PROCEDURE;
    DECLARE PTR ADDRESS;
    DECLARE BVAR BASED PTR BYTE;

    /* CONSTANT LIST */
    PTR = .(10, 20, 30, 40, 50);
    CALL PRINT$TEST(.'clist1 $', BVAR);  /* 10 */

    PTR = PTR + 2;
    CALL PRINT$TEST(.'clist2 $', BVAR);  /* 30 */

END TEST$CONSTLIST;

/* ==================================================================
 * TEST SECTION 19: BOOLEAN EXPRESSIONS
 * ================================================================== */

TEST$BOOLEAN: PROCEDURE;
    DECLARE A ADDRESS, B ADDRESS;
    DECLARE X BYTE;

    A = 1;
    B = 0;

    /* AND OF COMPARISONS */
    IF A > 0 AND B = 0 THEN
        CALL PRINT$TEST(.'bool1 $', 1);  /* 1 */
    ELSE
        CALL PRINT$TEST(.'bool1 $', 0);

    /* OR OF COMPARISONS */
    IF A > 10 OR B = 0 THEN
        CALL PRINT$TEST(.'bool2 $', 1);  /* 1 */
    ELSE
        CALL PRINT$TEST(.'bool2 $', 0);

    /* NOT OF COMPARISON */
    IF NOT (A = 0) THEN
        CALL PRINT$TEST(.'bool3 $', 1);  /* 1 */
    ELSE
        CALL PRINT$TEST(.'bool3 $', 0);

    /* BOOLEAN AS VALUE */
    X = (A > 0) AND (B = 0);
    CALL PRINT$TEST(.'bool4 $', X);  /* 255 (TRUE) */

    X = (A = 0) AND (B = 0);
    CALL PRINT$TEST(.'bool5 $', X);  /* 0 (FALSE) */

END TEST$BOOLEAN;

/* ==================================================================
 * TEST SECTION 20: EDGE CASES AND BOUNDARY VALUES
 * ================================================================== */

TEST$EDGE: PROCEDURE;
    DECLARE A ADDRESS;
    DECLARE X BYTE;

    /* MAX BYTE VALUE */
    X = 255;
    CALL PRINT$TEST(.'edge1 $', X);  /* 255 */

    /* MAX ADDRESS VALUE */
    A = 65535;
    CALL PRINT$TEST(.'edge2 $', A);  /* 65535 */

    /* ZERO */
    A = 0;
    CALL PRINT$TEST(.'edge3 $', A);  /* 0 */

    /* BYTE OVERFLOW (SHOULD WRAP) */
    X = 255;
    X = X + 1;
    CALL PRINT$TEST(.'edge4 $', X);  /* 0 */

    /* BYTE UNDERFLOW (SHOULD WRAP) */
    X = 0;
    X = X - 1;
    CALL PRINT$TEST(.'edge5 $', X);  /* 255 */

    /* DIVIDE BY LARGER */
    A = 5 / 10;
    CALL PRINT$TEST(.'edge6 $', A);  /* 0 */

    /* MODULO WITH LARGER DIVISOR */
    A = 5 MOD 10;
    CALL PRINT$TEST(.'edge7 $', A);  /* 5 */

END TEST$EDGE;

/* ==================================================================
 * MAIN PROGRAM
 * ================================================================== */

MAIN: PROCEDURE;
    CALL PRINT$STR(.'PL/M-80 Compiler Test Suite$');
    CALL CRLF;
    CALL PRINT$STR(.'==========================$');
    CALL CRLF;
    CALL CRLF;

    CALL TEST$ARITHMETIC;
    CALL TEST$BITWISE;
    CALL TEST$SHIFTS;
    CALL TEST$COMPARE;
    CALL TEST$WHILE;
    CALL TEST$ITERATIVE;
    CALL TEST$CASE;
    /* CALL TEST$GOTO; */
    CALL TEST$ARRAYS;
    CALL TEST$HIGHLOW;
    CALL TEST$PROCEDURES;
    CALL TEST$STRUCTURES;
    CALL TEST$BASED;
    CALL TEST$DATA;
    CALL TEST$EMBED;
    CALL TEST$MULTI$ASSIGN;
    CALL TEST$LOCATION;
    CALL TEST$CONSTLIST;
    CALL TEST$BOOLEAN;
    CALL TEST$EDGE;

    CALL CRLF;
    CALL PRINT$STR(.'Tests complete.$');
    CALL CRLF;

END MAIN;

/* START EXECUTION */
CALL MAIN;

END TESTSUITE;

EOF
